# dom

HTML DOM parser / editor / beautifier / autocloser

Простой и быстрый HTML DOM парсер/редактор.
Совместим с PHP 7.3
	
Содержит класс DOM-узла (html), а также удобные функции:
	
		url_abs() - абсолютизация URL
		url_replace() - замена вашим колбеком голых доменов и URL в тексте, находящихся вне href-атрибутов
		cu_download() - скачивание страниц с приемом заголовка Content-Type
	
	Пример использования:
	
		$p = new html();
		$p->inner(file_get_contents('/tmp/somefile.html'));
		$p->iterate(function($node, &$c){
			if ($node->tag=='a')
			{echo $node->inner().'<br>';}
		});
		
	Описание:
	
		- умеет делать выборку по CSS3-селектору + возможности jQuery
		- есть полезные функции для поиска повторяющихся участков html-кода: forks(), search(), итд
		- "узел" - это объект типа html (или его наследник)
		- "документ" и "корневой узел" это одно и то же
		- корневой узел всегда один
		- у тегов типов '#text' и '#comment' не бывает дочерних узлов
		- узлы остальных типов не хранят какую-либо текстовую информацию
		- дерево можно редактировать в любой момент: модифицировать или переносить узлы
		- если закрывашка пуста, это еще не значит что это тег незакрывающегося типа
		- любой не-HTML тег (т.е. не входящий в HTML_ELEMENTS_ALL) может быть закрыт если у него имеется слеш ("/") на конце открывающего блока тега. Т.е. он не будет требовать закрывающего тега ("self closing").
		- html-entities не декодируются кроме как в атрибутах
		- закрывающиеся теги, которые не были открыты (т.е. лишние закрывашки) парсер игнорирует (т.е. если после этого собрать документ, то в результате они не появятся), за исключением закрывашек: </p>, </br> - они преврашаются в отдельные пустые теги соответствующих типов (т.е. открывашка + закрывашка).
		- в имени тега могут присутствовать практически любые символы (в т.ч. тире, точки, любые utf-8 символы, итд), но начинаться оно должно строго с англ. буквы (a-z)
			- если имя тега начинается с "!", и это не doctype, то такой тег будет преобразован в комментарий
		- умеет парсить XML-файлы (и даже HTML-файлы, содержащие php-код, но с большими оговорками!):
			- XML-прологи могут встречаться в любом участке документа (в т.ч. в виде php-блоков кода), парсер помечает их как комментарии (тип тега - #comment). Для пролога открывашкой служит "< ?", а закрывашкой "? >" (без пробелов).
			- XML-документы трактует как HTML-документы, в некоторых случаях (связанных с XML-особенностями) это может влиять на корректность разбора
			- ВАЖНО: php-блоки не могут находиться внутри блока тега, в т.ч. внутри атрибутов или их имен. Иначе парсер неверно прочитает структуру документа. Поэтому для работы с текстами, содержащими php-блоки лучше перед парсингом заменяйте php-блоки на некоторый неиспользуемый ASCII-символ (скажем, нульбайт), а после - восстановите. 
		- блоки CDATA не замечает, читает их как и остальной (обычный) текст
		- "открепленный узел" свое состояние не меняет, с ним можно продолжать работу, но стоит понимать, что он помнит своего (прежнего) родителя и находится в невалидном состоянии (значение parent у него невалидно). Сделать его валидным снова можно передав его в качестве параметра любой из функций:
			- append()
			- prepend()
			- replace()
			- replace_inner()
		- поддерживается и корректно обрабатывается операция clone
		- поддерживает красивый var_dump() для узлов (без гигантских листингов, удобно)
